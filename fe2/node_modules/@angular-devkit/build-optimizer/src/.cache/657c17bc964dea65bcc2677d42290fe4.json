{"remainingRequest":"/home/alvaro/practicaEmpresarial/CMR--ALVARO/cp/fe2/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/alvaro/practicaEmpresarial/CMR--ALVARO/cp/fe2/node_modules/@ngx-pwa/local-storage/fesm5/local-storage.js","dependencies":[{"path":"/home/alvaro/practicaEmpresarial/CMR--ALVARO/cp/fe2/node_modules/@ngx-pwa/local-storage/fesm5/local-storage.js","mtime":1530584427854},{"path":"/home/alvaro/practicaEmpresarial/CMR--ALVARO/cp/fe2/node_modules/cache-loader/dist/cjs.js","mtime":1530584427962},{"path":"/home/alvaro/practicaEmpresarial/CMR--ALVARO/cp/fe2/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1530584427250}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START _angular_core,_angular_core,_angular_common,rxjs,rxjs_operators PURE_IMPORTS_END */\nimport { Inject, Injectable, InjectionToken, Optional, PLATFORM_ID, defineInjectable, inject } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { ReplaySubject, fromEvent, of, race, throwError } from 'rxjs';\nimport { first, map, mergeMap } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar LOCAL_STORAGE_PREFIX = /*@__PURE__*/ new InjectionToken('localStoragePrefix', { providedIn: 'root', factory: function () { return ''; } });\n/**\n * @record\n */\n/**\n * @param {?} config\n * @return {?}\n */\nfunction localStorageProviders(config) {\n    return [\n        config.prefix ? { provide: LOCAL_STORAGE_PREFIX, useValue: config.prefix } : []\n    ];\n}\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar IndexedDBDatabase = /** @class */ /*@__PURE__*/ (function () {\n    /**\n     * Connects to IndexedDB\n     */\n    function IndexedDBDatabase(prefix) {\n        if (prefix === void 0) {\n            prefix = null;\n        }\n        this.prefix = prefix;\n        /**\n         * IndexedDB database name for local storage\n         */\n        this.dbName = 'ngStorage';\n        /**\n         * IndexedDB object store name for local storage\n         */\n        this.objectStoreName = 'localStorage';\n        /**\n         * IndexedDB key path name for local storage (where an item's key will be stored)\n         */\n        this.keyPath = 'key';\n        /**\n         * IndexedDB data path name for local storage (where items' value will be stored)\n         */\n        this.dataPath = 'value';\n        if (prefix) {\n            this.dbName = prefix + \"_\" + this.dbName;\n        }\n        if (prefix) {\n            this.dbName = prefix + \"_\" + this.dbName;\n        }\n        /* Creating the RxJS ReplaySubject */\n        this.database = new ReplaySubject();\n        /* Connecting to IndexedDB */\n        this.connect();\n    }\n    /**\n     * Gets an item value in local storage\n     * @param key The item's key\n     * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n     */\n    /**\n     * Gets an item value in local storage\n     * @template T\n     * @param {?} key The item's key\n     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n     */\n    IndexedDBDatabase.prototype.getItem = /**\n     * Gets an item value in local storage\n     * @template T\n     * @param {?} key The item's key\n     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n     */\n        function (key) {\n            var _this = this;\n            /* Opening a trasaction and requesting the item in local storage */\n            return this.transaction().pipe(map(function (transaction) { return transaction.get(key); }), mergeMap(function (request) {\n                /* Listening to the success event, and passing the item value if found, null otherwise */\n                var /** @type {?} */ success = ( /** @type {?} */(fromEvent(request, 'success'))).pipe(map(function (event) { return ( /** @type {?} */(event.target)).result; }), map(function (result) { return result && (_this.dataPath in result) ? ( /** @type {?} */(result[_this.dataPath])) : null; }));\n                /* Merging success and errors events and autoclosing the observable */\n                return ( /** @type {?} */(race(success, _this.toErrorObservable(request, \"getter\"))))\n                    .pipe(first());\n            }), first());\n        };\n    /**\n     * Sets an item in local storage\n     * @param key The item's key\n     * @param data The item's value, must NOT be null or undefined\n     * @returns An RxJS Observable to wait the end of the operation\n     */\n    /**\n     * Sets an item in local storage\n     * @param {?} key The item's key\n     * @param {?} data The item's value, must NOT be null or undefined\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n    IndexedDBDatabase.prototype.setItem = /**\n     * Sets an item in local storage\n     * @param {?} key The item's key\n     * @param {?} data The item's value, must NOT be null or undefined\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n        function (key, data) {\n            var _this = this;\n            /* Storing null is not correctly supported by IndexedDB and unnecessary here */\n            if (data == null) {\n                return of(true);\n            }\n            /* Opening a transaction and checking if the item already exists in local storage */\n            return this.getItem(key).pipe(map(function (existingData) { return (existingData == null) ? 'add' : 'put'; }), mergeMap(function (method) {\n                /* Opening a transaction */\n                return _this.transaction('readwrite').pipe(mergeMap(function (transaction) {\n                    var /** @type {?} */ request;\n                    /* Adding or updating local storage, based on previous checking */\n                    switch (method) {\n                        case 'add':\n                            request = transaction.add((_a = {}, _a[_this.dataPath] = data, _a), key);\n                            break;\n                        case 'put':\n                        default:\n                            request = transaction.put((_b = {}, _b[_this.dataPath] = data, _b), key);\n                            break;\n                    }\n                    /* Merging success (passing true) and error events and autoclosing the observable */\n                    return ( /** @type {?} */(race(_this.toSuccessObservable(request), _this.toErrorObservable(request, \"setter\"))))\n                        .pipe(first());\n                    var _a, _b;\n                }));\n            }), first());\n        };\n    /**\n     * Deletes an item in local storage\n     * @param key The item's key\n     * @returns An RxJS Observable to wait the end of the operation\n     */\n    /**\n     * Deletes an item in local storage\n     * @param {?} key The item's key\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n    IndexedDBDatabase.prototype.removeItem = /**\n     * Deletes an item in local storage\n     * @param {?} key The item's key\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n        function (key) {\n            var _this = this;\n            /* Opening a transaction and checking if the item exists in local storage */\n            return this.getItem(key).pipe(mergeMap(function (data) {\n                /* If the item exists in local storage */\n                if (data != null) {\n                    /* Opening a transaction */\n                    return _this.transaction('readwrite').pipe(mergeMap(function (transaction) {\n                        /* Deleting the item in local storage */\n                        var /** @type {?} */ request = transaction.delete(key);\n                        /* Merging success (passing true) and error events and autoclosing the observable */\n                        return ( /** @type {?} */(race(_this.toSuccessObservable(request), _this.toErrorObservable(request, \"remover\"))))\n                            .pipe(first());\n                    }));\n                }\n                /* Passing true if the item does not exist in local storage */\n                return of(true);\n            }), first());\n        };\n    /**\n     * Deletes all items from local storage\n     * @returns An RxJS Observable to wait the end of the operation\n     */\n    /**\n     * Deletes all items from local storage\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n    IndexedDBDatabase.prototype.clear = /**\n     * Deletes all items from local storage\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n        function () {\n            var _this = this;\n            /* Opening a transaction */\n            return this.transaction('readwrite').pipe(mergeMap(function (transaction) {\n                /* Deleting all items from local storage */\n                var /** @type {?} */ request = transaction.clear();\n                /* Merging success (passing true) and error events and autoclosing the observable */\n                return ( /** @type {?} */(race(_this.toSuccessObservable(request), _this.toErrorObservable(request, \"clearer\"))))\n                    .pipe(first());\n            }), first());\n        };\n    /**\n     * Connects to IndexedDB and creates the object store on first time\n     */\n    /**\n     * Connects to IndexedDB and creates the object store on first time\n     * @return {?}\n     */\n    IndexedDBDatabase.prototype.connect = /**\n     * Connects to IndexedDB and creates the object store on first time\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            /* Connecting to IndexedDB */\n            var /** @type {?} */ request = indexedDB.open(this.dbName);\n            /* Listening the event fired on first connection, creating the object store for local storage */\n            ( /** @type {?} */(fromEvent(request, 'upgradeneeded')))\n                .pipe(first())\n                .subscribe(function (event) {\n                /* Getting the database connection */\n                var /** @type {?} */ database = /** @type {?} */ (( /** @type {?} */(event.target)).result);\n                /* Checking if the object store already exists, to avoid error */\n                if (!database.objectStoreNames.contains(_this.objectStoreName)) {\n                    /* Creating the object store for local storage */\n                    database.createObjectStore(_this.objectStoreName);\n                }\n            });\n            /* Listening the success event and converting to an RxJS Observable */\n            var /** @type {?} */ success = /** @type {?} */ (fromEvent(request, 'success'));\n            /* Merging success and errors events */\n            ( /** @type {?} */(race(success, this.toErrorObservable(request, \"connection\"))))\n                .pipe(first())\n                .subscribe(function (event) {\n                /* Storing the database connection for further access */\n                /* Storing the database connection for further access */\n                _this.database.next(/** @type {?} */ (( /** @type {?} */(event.target)).result));\n            }, function (error) {\n                _this.database.error(/** @type {?} */ (error));\n            });\n        };\n    /**\n     * Opens an IndexedDB transaction and gets the local storage object store\n     * @param mode Default to 'readonly' for read operations, or 'readwrite' for write operations\n     * @returns An IndexedDB transaction object store, wrapped in an RxJS Observable\n     */\n    /**\n     * Opens an IndexedDB transaction and gets the local storage object store\n     * @param {?=} mode Default to 'readonly' for read operations, or 'readwrite' for write operations\n     * @return {?} An IndexedDB transaction object store, wrapped in an RxJS Observable\n     */\n    IndexedDBDatabase.prototype.transaction = /**\n     * Opens an IndexedDB transaction and gets the local storage object store\n     * @param {?=} mode Default to 'readonly' for read operations, or 'readwrite' for write operations\n     * @return {?} An IndexedDB transaction object store, wrapped in an RxJS Observable\n     */\n        function (mode) {\n            var _this = this;\n            if (mode === void 0) {\n                mode = 'readonly';\n            }\n            /* From the IndexedDB connection, opening a transaction and getting the local storage objet store */\n            return this.database\n                .pipe(map(function (database) { return database.transaction([_this.objectStoreName], mode).objectStore(_this.objectStoreName); }));\n        };\n    /**\n     * Transforms a IndexedDB success event in an RxJS Observable\n     * @param request The request to listen\n     * @returns A RxJS Observable with true value\n     */\n    /**\n     * Transforms a IndexedDB success event in an RxJS Observable\n     * @param {?} request The request to listen\n     * @return {?} A RxJS Observable with true value\n     */\n    IndexedDBDatabase.prototype.toSuccessObservable = /**\n     * Transforms a IndexedDB success event in an RxJS Observable\n     * @param {?} request The request to listen\n     * @return {?} A RxJS Observable with true value\n     */\n        function (request) {\n            /* Transforming a IndexedDB success event in an RxJS Observable with true value */\n            return ( /** @type {?} */(fromEvent(request, 'success')))\n                .pipe(map(function () { return true; }));\n        };\n    /**\n     * Transforms a IndexedDB error event in an RxJS ErrorObservable\n     * @param request The request to listen\n     * @param error Optionnal details about the error's origin\n     * @returns A RxJS ErrorObservable\n     */\n    /**\n     * Transforms a IndexedDB error event in an RxJS ErrorObservable\n     * @param {?} request The request to listen\n     * @param {?=} error Optionnal details about the error's origin\n     * @return {?} A RxJS ErrorObservable\n     */\n    IndexedDBDatabase.prototype.toErrorObservable = /**\n     * Transforms a IndexedDB error event in an RxJS ErrorObservable\n     * @param {?} request The request to listen\n     * @param {?=} error Optionnal details about the error's origin\n     * @return {?} A RxJS ErrorObservable\n     */\n        function (request, error) {\n            if (error === void 0) {\n                error = \"\";\n            }\n            /* Transforming a IndexedDB error event in an RxJS ErrorObservable */\n            return ( /** @type {?} */(fromEvent(request, 'error')))\n                .pipe(mergeMap(function (event) { return throwError(new Error(\"IndexedDB \" + error + \" issue : \" + request.error.message + \".\")); }));\n        };\n    /** @nocollapse */ IndexedDBDatabase.ngInjectableDef = defineInjectable({ factory: function IndexedDBDatabase_Factory() { return new IndexedDBDatabase(inject(LOCAL_STORAGE_PREFIX, 8)); }, token: IndexedDBDatabase, providedIn: \"root\" });\n    return IndexedDBDatabase;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar LocalStorageDatabase = /** @class */ /*@__PURE__*/ (function () {\n    function LocalStorageDatabase(userPrefix) {\n        if (userPrefix === void 0) {\n            userPrefix = null;\n        }\n        this.userPrefix = userPrefix;\n        /* Initializing native localStorage right now to be able to check its support on class instanciation */\n        this.prefix = '';\n        if (userPrefix) {\n            this.prefix = userPrefix + \"_\";\n        }\n    }\n    /**\n     * Gets an item value in local storage\n     * @param key The item's key\n     * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n     */\n    /**\n     * Gets an item value in local storage\n     * @template T\n     * @param {?} key The item's key\n     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n     */\n    LocalStorageDatabase.prototype.getItem = /**\n     * Gets an item value in local storage\n     * @template T\n     * @param {?} key The item's key\n     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n     */\n        function (key) {\n            var /** @type {?} */ unparsedData = localStorage.getItem(\"\" + this.prefix + key);\n            var /** @type {?} */ parsedData = null;\n            if (unparsedData != null) {\n                try {\n                    parsedData = JSON.parse(unparsedData);\n                }\n                catch ( /** @type {?} */error) {\n                    return throwError(new Error(\"Invalid data in localStorage.\"));\n                }\n            }\n            return of(parsedData);\n        };\n    /**\n     * Sets an item in local storage\n     * @param key The item's key\n     * @param data The item's value, must NOT be null or undefined\n     * @returns An RxJS Observable to wait the end of the operation\n     */\n    /**\n     * Sets an item in local storage\n     * @param {?} key The item's key\n     * @param {?} data The item's value, must NOT be null or undefined\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n    LocalStorageDatabase.prototype.setItem = /**\n     * Sets an item in local storage\n     * @param {?} key The item's key\n     * @param {?} data The item's value, must NOT be null or undefined\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n        function (key, data) {\n            localStorage.setItem(\"\" + this.prefix + key, JSON.stringify(data));\n            return of(true);\n        };\n    /**\n     * Deletes an item in local storage\n     * @param key The item's key\n     * @returns An RxJS Observable to wait the end of the operation\n     */\n    /**\n     * Deletes an item in local storage\n     * @param {?} key The item's key\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n    LocalStorageDatabase.prototype.removeItem = /**\n     * Deletes an item in local storage\n     * @param {?} key The item's key\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n        function (key) {\n            localStorage.removeItem(\"\" + this.prefix + key);\n            return of(true);\n        };\n    /**\n     * Deletes all items from local storage\n     * @returns An RxJS Observable to wait the end of the operation\n     */\n    /**\n     * Deletes all items from local storage\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n    LocalStorageDatabase.prototype.clear = /**\n     * Deletes all items from local storage\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n        function () {\n            localStorage.clear();\n            return of(true);\n        };\n    /** @nocollapse */ LocalStorageDatabase.ngInjectableDef = defineInjectable({ factory: function LocalStorageDatabase_Factory() { return new LocalStorageDatabase(inject(LOCAL_STORAGE_PREFIX, 8)); }, token: LocalStorageDatabase, providedIn: \"root\" });\n    return LocalStorageDatabase;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nvar MockLocalDatabase = /** @class */ /*@__PURE__*/ (function () {\n    function MockLocalDatabase() {\n        this.localStorage = new Map();\n    }\n    /**\n     * Gets an item value in local storage\n     * @param key The item's key\n     * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n     */\n    /**\n     * Gets an item value in local storage\n     * @template T\n     * @param {?} key The item's key\n     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n     */\n    MockLocalDatabase.prototype.getItem = /**\n     * Gets an item value in local storage\n     * @template T\n     * @param {?} key The item's key\n     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n     */\n        function (key) {\n            var /** @type {?} */ rawData = this.localStorage.get(key);\n            return of((rawData !== undefined) ? rawData : null);\n        };\n    /**\n     * Sets an item in local storage\n     * @param key The item's key\n     * @param data The item's value, must NOT be null or undefined\n     * @returns An RxJS Observable to wait the end of the operation\n     */\n    /**\n     * Sets an item in local storage\n     * @param {?} key The item's key\n     * @param {?} data The item's value, must NOT be null or undefined\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n    MockLocalDatabase.prototype.setItem = /**\n     * Sets an item in local storage\n     * @param {?} key The item's key\n     * @param {?} data The item's value, must NOT be null or undefined\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n        function (key, data) {\n            this.localStorage.set(key, data);\n            return of(true);\n        };\n    /**\n     * Deletes an item in local storage\n     * @param key The item's key\n     * @returns An RxJS Observable to wait the end of the operation\n     */\n    /**\n     * Deletes an item in local storage\n     * @param {?} key The item's key\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n    MockLocalDatabase.prototype.removeItem = /**\n     * Deletes an item in local storage\n     * @param {?} key The item's key\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n        function (key) {\n            this.localStorage.delete(key);\n            return of(true);\n        };\n    /**\n     * Deletes all items from local storage\n     * @returns An RxJS Observable to wait the end of the operation\n     */\n    /**\n     * Deletes all items from local storage\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n    MockLocalDatabase.prototype.clear = /**\n     * Deletes all items from local storage\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n        function () {\n            this.localStorage.clear();\n            return of(true);\n        };\n    /** @nocollapse */ MockLocalDatabase.ngInjectableDef = defineInjectable({ factory: function MockLocalDatabase_Factory() { return new MockLocalDatabase(); }, token: MockLocalDatabase, providedIn: \"root\" });\n    return MockLocalDatabase;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @param {?} platformId\n * @param {?} prefix\n * @return {?}\n */\nfunction localDatabaseFactory(platformId, prefix) {\n    if (isPlatformBrowser(platformId) && ('indexedDB' in window) && (indexedDB !== undefined) && (indexedDB !== null)) {\n        /* Try with IndexedDB in modern browsers */\n        return new IndexedDBDatabase(prefix);\n    }\n    else if (isPlatformBrowser(platformId) && ('localStorage' in window) && (localStorage !== undefined) && (localStorage !== null)) {\n        /* Try with localStorage in old browsers (IE9) */\n        return new LocalStorageDatabase(prefix);\n    }\n    else {\n        /* Fake database for server-side rendering (Universal) */\n        return new MockLocalDatabase();\n    }\n}\n/**\n * @abstract\n */\nvar LocalDatabase = /** @class */ /*@__PURE__*/ (function () {\n    function LocalDatabase() {\n    }\n    /** @nocollapse */ LocalDatabase.ngInjectableDef = defineInjectable({ factory: function LocalDatabase_Factory() { return localDatabaseFactory(inject(PLATFORM_ID), inject(LOCAL_STORAGE_PREFIX, 8)); }, token: LocalDatabase, providedIn: \"root\" });\n    return LocalDatabase;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * \\@todo Add other JSON Schema validation features\n */\nvar JSONValidator = /** @class */ /*@__PURE__*/ (function () {\n    function JSONValidator() {\n    }\n    /**\n     * Validate a JSON data against a JSON Schema\n     * @param data JSON data to validate\n     * @param schema Subset of JSON Schema.\n     * Types are enforced to validate everything:\n     * each value MUST have 'type' or 'properties' or 'items' or 'const' or 'enum'.\n     * Therefore, unlike the spec, booleans are not allowed as schemas.\n     * Not all validation features are supported: just follow the interface.\n     * @returns If data is valid : true, if it is invalid : false, and throws if the schema is invalid\n     */\n    /**\n     * Validate a JSON data against a JSON Schema\n     * @param {?} data JSON data to validate\n     * @param {?} schema Subset of JSON Schema.\n     * Types are enforced to validate everything:\n     * each value MUST have 'type' or 'properties' or 'items' or 'const' or 'enum'.\n     * Therefore, unlike the spec, booleans are not allowed as schemas.\n     * Not all validation features are supported: just follow the interface.\n     * @return {?} If data is valid : true, if it is invalid : false, and throws if the schema is invalid\n     */\n    JSONValidator.prototype.validate = /**\n     * Validate a JSON data against a JSON Schema\n     * @param {?} data JSON data to validate\n     * @param {?} schema Subset of JSON Schema.\n     * Types are enforced to validate everything:\n     * each value MUST have 'type' or 'properties' or 'items' or 'const' or 'enum'.\n     * Therefore, unlike the spec, booleans are not allowed as schemas.\n     * Not all validation features are supported: just follow the interface.\n     * @return {?} If data is valid : true, if it is invalid : false, and throws if the schema is invalid\n     */\n        function (data, schema) {\n            /** @todo When TS 2.8, explore if this is possible with conditional types */\n            if (((!(schema.hasOwnProperty('const') && schema.const !== undefined)\n                && !(schema.hasOwnProperty('enum') && schema.enum != null) && !(schema.hasOwnProperty('type') && schema.type != null))\n                || schema.type === 'array' || schema.type === 'object')\n                && !(schema.hasOwnProperty('properties') && schema.properties != null) && !(schema.hasOwnProperty('items') && schema.items != null)) {\n                throw new Error(\"Each value must have a 'type' or 'properties' or 'items' or 'const' or 'enum', to enforce strict types.\");\n            }\n            if (schema.hasOwnProperty('const') && schema.const !== undefined && (data !== schema.const)) {\n                return false;\n            }\n            if (!this.validateEnum(data, schema)) {\n                return false;\n            }\n            if (!this.validateType(data, schema)) {\n                return false;\n            }\n            if (!this.validateItems(data, schema)) {\n                return false;\n            }\n            if (!this.validateProperties(data, schema)) {\n                return false;\n            }\n            if (!this.validateRequired(data, schema)) {\n                return false;\n            }\n            return true;\n        };\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    JSONValidator.prototype.isObjectNotNull = /**\n     * @param {?} value\n     * @return {?}\n     */\n        function (value) {\n            return (value !== null) && (typeof value === 'object');\n        };\n    /**\n     * @param {?} data\n     * @param {?} schema\n     * @return {?}\n     */\n    JSONValidator.prototype.validateProperties = /**\n     * @param {?} data\n     * @param {?} schema\n     * @return {?}\n     */\n        function (data, schema) {\n            if (!schema.hasOwnProperty('properties') || (schema.properties == null)) {\n                return true;\n            }\n            if (!this.isObjectNotNull(data)) {\n                return false;\n            }\n            /**\n                 * Check if the object doesn't have more properties than expected\n                 * Equivalent of additionalProperties: false\n                 */\n            if (Object.keys(schema.properties).length !== Object.keys(data).length) {\n                return false;\n            }\n            /* Recursively validate all properties */\n            for (var /** @type {?} */ property in schema.properties) {\n                if (schema.properties.hasOwnProperty(property) && data.hasOwnProperty(property)) {\n                    if (!this.validate(data[property], schema.properties[property])) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n    /**\n     * @param {?} data\n     * @param {?} schema\n     * @return {?}\n     */\n    JSONValidator.prototype.validateRequired = /**\n     * @param {?} data\n     * @param {?} schema\n     * @return {?}\n     */\n        function (data, schema) {\n            if (!schema.hasOwnProperty('required') || (schema.required == null)) {\n                return true;\n            }\n            if (!this.isObjectNotNull(data)) {\n                return false;\n            }\n            for (var _i = 0, _a = schema.required; _i < _a.length; _i++) {\n                var requiredProp = _a[_i];\n                /* Checks if the property is present in the schema 'properties' */\n                if (!schema.properties || !schema.properties.hasOwnProperty(requiredProp)) {\n                    throw new Error(\"'required' properties must be described in 'properties' too.\");\n                }\n                /* Checks if the property is present in the data */\n                if (!data.hasOwnProperty(requiredProp)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n    /**\n     * @param {?} data\n     * @param {?} schema\n     * @return {?}\n     */\n    JSONValidator.prototype.validateEnum = /**\n     * @param {?} data\n     * @param {?} schema\n     * @return {?}\n     */\n        function (data, schema) {\n            if (!schema.hasOwnProperty('enum') || (schema.enum == null)) {\n                return true;\n            }\n            /** @todo Move to ES2016 .includes() ? */\n            return (schema.enum.indexOf(data) !== -1);\n        };\n    /**\n     * @param {?} data\n     * @param {?} schema\n     * @return {?}\n     */\n    JSONValidator.prototype.validateType = /**\n     * @param {?} data\n     * @param {?} schema\n     * @return {?}\n     */\n        function (data, schema) {\n            if (!schema.hasOwnProperty('type') || (schema.type == null)) {\n                return true;\n            }\n            switch (schema.type) {\n                case 'null':\n                    return data === null;\n                case 'string':\n                    return this.validateString(data, schema);\n                case 'number':\n                case 'integer':\n                    return this.validateNumber(data, schema);\n                case 'boolean':\n                    return typeof data === 'boolean';\n                case 'object':\n                    return typeof data === 'object';\n                case 'array':\n                    return Array.isArray(data);\n            }\n        };\n    /**\n     * @param {?} data\n     * @param {?} schema\n     * @return {?}\n     */\n    JSONValidator.prototype.validateItems = /**\n     * @param {?} data\n     * @param {?} schema\n     * @return {?}\n     */\n        function (data, schema) {\n            if (!schema.hasOwnProperty('items') || (schema.items == null)) {\n                return true;\n            }\n            if (!Array.isArray(data)) {\n                return false;\n            }\n            if (schema.hasOwnProperty('maxItems') && (schema.maxItems != null)) {\n                if (!Number.isInteger(schema.maxItems) || schema.maxItems < 0) {\n                    throw new Error(\"'maxItems' must be a non-negative integer.\");\n                }\n                if (data.length > schema.maxItems) {\n                    return false;\n                }\n            }\n            if (schema.hasOwnProperty('minItems') && (schema.minItems != null)) {\n                if (!Number.isInteger(schema.minItems) || schema.minItems < 0) {\n                    throw new Error(\"'minItems' must be a non-negative integer.\");\n                }\n                if (data.length < schema.minItems) {\n                    return false;\n                }\n            }\n            if (schema.hasOwnProperty('uniqueItems') && (schema.uniqueItems != null)) {\n                if (schema.uniqueItems) {\n                    var /** @type {?} */ dataSet = new Set(data);\n                    if (data.length !== dataSet.size) {\n                        return false;\n                    }\n                }\n            }\n            if (Array.isArray(schema.items)) {\n                return this.validateItemsList(data, schema);\n            }\n            for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {\n                var value = data_1[_i];\n                if (!this.validate(value, schema.items)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n    /**\n     * @param {?} data\n     * @param {?} schema\n     * @return {?}\n     */\n    JSONValidator.prototype.validateItemsList = /**\n     * @param {?} data\n     * @param {?} schema\n     * @return {?}\n     */\n        function (data, schema) {\n            var /** @type {?} */ items = /** @type {?} */ (schema.items);\n            if (data.length !== items.length) {\n                return false;\n            }\n            for (var /** @type {?} */ i = 0; i < items.length; i += 1) {\n                if (!this.validate(data[i], items[i])) {\n                    return false;\n                }\n            }\n            return true;\n        };\n    /**\n     * @param {?} data\n     * @param {?} schema\n     * @return {?}\n     */\n    JSONValidator.prototype.validateString = /**\n     * @param {?} data\n     * @param {?} schema\n     * @return {?}\n     */\n        function (data, schema) {\n            if (typeof data !== 'string') {\n                return false;\n            }\n            if (schema.hasOwnProperty('maxLength') && (schema.maxLength != null)) {\n                if (!Number.isInteger(schema.maxLength) || schema.maxLength < 0) {\n                    throw new Error(\"'maxLength' must be a non-negative integer.\");\n                }\n                if (data.length > schema.maxLength) {\n                    return false;\n                }\n            }\n            if (schema.hasOwnProperty('minLength') && (schema.minLength != null)) {\n                if (!Number.isInteger(schema.minLength) || schema.minLength < 0) {\n                    throw new Error(\"'minLength' must be a non-negative integer.\");\n                }\n                if (data.length < schema.minLength) {\n                    return false;\n                }\n            }\n            if (schema.hasOwnProperty('pattern') && (schema.pattern != null)) {\n                var /** @type {?} */ regularExpression = new RegExp(schema.pattern);\n                if (!regularExpression.test(data)) {\n                    return false;\n                }\n            }\n            return true;\n        };\n    /**\n     * @param {?} data\n     * @param {?} schema\n     * @return {?}\n     */\n    JSONValidator.prototype.validateNumber = /**\n     * @param {?} data\n     * @param {?} schema\n     * @return {?}\n     */\n        function (data, schema) {\n            if (typeof data !== 'number') {\n                return false;\n            }\n            if ((schema.type === 'integer') && !Number.isInteger(data)) {\n                return false;\n            }\n            if (schema.hasOwnProperty('multipleOf') && (schema.multipleOf != null)) {\n                if (schema.multipleOf <= 0) {\n                    throw new Error(\"'multipleOf' must be a number strictly greater than 0.\");\n                }\n                if (!Number.isInteger(data / schema.multipleOf)) {\n                    return false;\n                }\n            }\n            if (schema.hasOwnProperty('maximum') && (schema.maximum != null)) {\n                if (data > schema.maximum) {\n                    return false;\n                }\n            }\n            if (schema.hasOwnProperty('exclusiveMaximum') && (schema.exclusiveMaximum != null)) {\n                if (data >= schema.exclusiveMaximum) {\n                    return false;\n                }\n            }\n            if (schema.hasOwnProperty('minimum') && (schema.minimum != null)) {\n                if (data < schema.minimum) {\n                    return false;\n                }\n            }\n            if (schema.hasOwnProperty('exclusiveMinimum') && (schema.exclusiveMinimum != null)) {\n                if (data <= schema.exclusiveMinimum) {\n                    return false;\n                }\n            }\n            return true;\n        };\n    /** @nocollapse */ JSONValidator.ngInjectableDef = defineInjectable({ factory: function JSONValidator_Factory() { return new JSONValidator(); }, token: JSONValidator, providedIn: \"root\" });\n    return JSONValidator;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @record\n */\nvar LocalStorage = /** @class */ /*@__PURE__*/ (function () {\n    function LocalStorage(database, jsonValidator) {\n        this.database = database;\n        this.jsonValidator = jsonValidator;\n        this.getItemOptionsDefault = {\n            schema: null\n        };\n    }\n    /**\n     * Gets an item value in local storage\n     * @param key The item's key\n     * @returns The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n     */\n    /**\n     * Gets an item value in local storage\n     * @template T\n     * @param {?} key The item's key\n     * @param {?=} options\n     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n     */\n    LocalStorage.prototype.getItem = /**\n     * Gets an item value in local storage\n     * @template T\n     * @param {?} key The item's key\n     * @param {?=} options\n     * @return {?} The item's value if the key exists, null otherwise, wrapped in an RxJS Observable\n     */\n        function (key, options) {\n            var _this = this;\n            if (options === void 0) {\n                options = this.getItemOptionsDefault;\n            }\n            return this.database.getItem(key).pipe(/* Validate data upon a json schema if requested */ mergeMap(function (data) {\n                if (options.schema && data !== null) {\n                    var /** @type {?} */ validation = true;\n                    try {\n                        validation = _this.jsonValidator.validate(data, options.schema);\n                    }\n                    catch ( /** @type {?} */error) {\n                        return throwError(error);\n                    }\n                    if (!validation) {\n                        return throwError(new Error(\"JSON invalid\"));\n                    }\n                }\n                return of(data);\n            }));\n        };\n    /**\n     * Sets an item in local storage\n     * @param key The item's key\n     * @param data The item's value, must NOT be null or undefined\n     * @returns An RxJS Observable to wait the end of the operation\n     */\n    /**\n     * Sets an item in local storage\n     * @param {?} key The item's key\n     * @param {?} data The item's value, must NOT be null or undefined\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n    LocalStorage.prototype.setItem = /**\n     * Sets an item in local storage\n     * @param {?} key The item's key\n     * @param {?} data The item's value, must NOT be null or undefined\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n        function (key, data) {\n            return this.database.setItem(key, data);\n        };\n    /**\n     * Deletes an item in local storage\n     * @param key The item's key\n     * @returns An RxJS Observable to wait the end of the operation\n     */\n    /**\n     * Deletes an item in local storage\n     * @param {?} key The item's key\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n    LocalStorage.prototype.removeItem = /**\n     * Deletes an item in local storage\n     * @param {?} key The item's key\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n        function (key) {\n            return this.database.removeItem(key);\n        };\n    /**\n     * Deletes all items from local storage\n     * @returns An RxJS Observable to wait the end of the operation\n     */\n    /**\n     * Deletes all items from local storage\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n    LocalStorage.prototype.clear = /**\n     * Deletes all items from local storage\n     * @return {?} An RxJS Observable to wait the end of the operation\n     */\n        function () {\n            return this.database.clear();\n        };\n    /**\n     * Sets an item in local storage, and auto-subscribes\n     * @param key The item's key\n     * @param data The item's value, must NOT be null or undefined\n     */\n    /**\n     * Sets an item in local storage, and auto-subscribes\n     * @param {?} key The item's key\n     * @param {?} data The item's value, must NOT be null or undefined\n     * @return {?}\n     */\n    LocalStorage.prototype.setItemSubscribe = /**\n     * Sets an item in local storage, and auto-subscribes\n     * @param {?} key The item's key\n     * @param {?} data The item's value, must NOT be null or undefined\n     * @return {?}\n     */\n        function (key, data) {\n            this.setItem(key, data).subscribe(function () { }, function () { });\n        };\n    /**\n     * Deletes an item in local storage, and auto-subscribes\n     * @param key The item's key\n     */\n    /**\n     * Deletes an item in local storage, and auto-subscribes\n     * @param {?} key The item's key\n     * @return {?}\n     */\n    LocalStorage.prototype.removeItemSubscribe = /**\n     * Deletes an item in local storage, and auto-subscribes\n     * @param {?} key The item's key\n     * @return {?}\n     */\n        function (key) {\n            this.removeItem(key).subscribe(function () { }, function () { });\n        };\n    /** Deletes all items from local storage, and auto-subscribes */\n    /**\n     * Deletes all items from local storage, and auto-subscribes\n     * @return {?}\n     */\n    LocalStorage.prototype.clearSubscribe = /**\n     * Deletes all items from local storage, and auto-subscribes\n     * @return {?}\n     */\n        function () {\n            this.clear().subscribe(function () { }, function () { });\n        };\n    /** @nocollapse */ LocalStorage.ngInjectableDef = defineInjectable({ factory: function LocalStorage_Factory() { return new LocalStorage(inject(LocalDatabase), inject(JSONValidator)); }, token: LocalStorage, providedIn: \"root\" });\n    return LocalStorage;\n}());\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n/**\n * Generated bundle index. Do not edit.\n */\nexport { LocalDatabase, IndexedDBDatabase, LocalStorageDatabase, MockLocalDatabase, JSONValidator, LocalStorage, localStorageProviders, LOCAL_STORAGE_PREFIX, localDatabaseFactory as ɵa };\n//# sourceMappingURL=local-storage.js.map\n",null]}